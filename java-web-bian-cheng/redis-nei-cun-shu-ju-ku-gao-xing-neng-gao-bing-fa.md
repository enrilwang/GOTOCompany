# redis内存数据库（高性能，高并发）

## redis介绍

Redis以slot作为数据单元，固定具有16384个slot，存储数据的key会进行crc16算法（循环冗余校验）得出一个值后对16384取余就是这个key存放的slot位置. key永远是字符串，value可以是字符串，哈希表，列表，集合

## redis功能

redis是内存数据库，读写速度非常快，因此被广泛应用于缓存方向。还可以拿来做分布式锁，甚至是消息队列。Redis还支持事务，持久化，lua脚本，多种集群方案。是一个开源的高性能key-value非关系缓存数据库,redis操作全是原子性的。

```text
set key value
setex key 秒数 value
ttl key 查找还剩多少秒
setnx key value 存在key不去set
expire key 秒数 为这个key设置存活时间
persist key 删除key的有效时长



```

### redis支持丰富的数据类型，为什么这么快

有string，list，set，hash，快的原因：1首先是数据结构简单，2是采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用考虑锁的问题，不存在加锁释放锁操作，也不会因为可能出现死锁而导致的性能消耗。3使用多路I/O复用模型，非堵塞IO。

## redis持久化策略

### RDB（默认模式，redis database，内存快照）

在RDB模式下，是在频率达到要求时，进行内存快照写入磁盘，又分为同步和异步，同步模式下：内存生成快照，并写入磁盘，异步模式下，内存生成快照，额外生成一块快照区，还是可以继续写数据，快照写入磁盘不影响数据变更。默认是异步。

### AOF

appendonly，每秒写一次命令，重启时，使用aof进行命令恢复，相当于重跑了一次命令



## redis集群服务

redis主从复制，只有主master具备写的能力，而从 slave只能读，如果master宕机，整个节点不具备写能力。因此redis哨兵可以让从节点变为主节点，那么整个节点就可以继续工作。这样之前的主恢复回来就直接当成整个节点的从即可。

redis哨兵就是帮助监控整个节点的，在主节点宕机等情况下，帮助重新选主。支持单哨兵和多哨兵。基于主从模型搭建哨兵



如果用集群时，对应几个服务器会平分16384个slot，然后都是master。

## 缓存数据的处理流程是怎么样的？

收到用户请求会先检查缓存中是否存在对应的数据，有则返回，没有就区数据库中查找是否存在对应的数据，有则更新缓存数据，没有的话就返回空数据。



```text
缓存穿透：大量请求的key不存在缓存中，直接请求到了数据库，
解决办法：检查用户参数或者使用 布隆过滤器（任何查询先进入过滤器筛查）

缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上。
比如在秒杀开始12小时前，统一存放了一批商品到redis中设置了缓存时间也是12小时，
秒杀开始，这些请求直接落到了数据库上。
解决办法：针对redis服务不可用：1。采用redis集群，避免单机出问题整个缓存服务都没办法使用
2。限流：避免同时处理大量的请求。
针对热点缓存失效的情况：1：设置不同的失效时间，比如随即设置缓存的失效时间 2。缓存永不失效

缓存常用的3种读写策略
1。旁路缓存模式 cache aside pattern（适合读请求比较多的场景）
    写： 先更新DB，然后直接删除cache
    读： 从cache中读取数据，读取到就直接返回，读不到去DB里面读取，再把数据放到cache中
    
2。读写穿透模式 read/write through pattern
    服务端把cache视为主要数据存储，一直在维护cache
    写： 先查cache，不存在则更新DB，cache存在，同步更新cache和db
    读： 从cache中读取，有就拿出来，没有就在db拿，再写入到cache

3。 异步缓存写入 write behind pattern
    都是由cache服务来负责cache和DB到读写 和2相似
    不同的是，2是同步更新，而3是更新缓存，不直接更新DB，之后批量更新DB
```

## 布隆过滤器（适合大量数据的时候用）

是一种数据结构，巧妙的概率型数据结构，特点是高效的插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在“，它的占用空间相比于其他数据结构更少。缺点是返回的结果是概率，不是确切的。

布隆过滤器是一个bit向量或者说bit数组。如果我们要映射一个值到布隆过滤器，我们需要使用不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的bit改为1。所以当查询某个值的时候，通过多个哈希值的映射找到对应bit位置上是否为1，如果有一个0，就说明肯定不在，如果都是1，说明有可能在



## BitMap（适合大数据的去重和查重）

定义一个很大的bit数组，每个元素对应bit数组的其中一位，对于整数，需要512M的空间，真正的bit数组其实是byte数组



