# MQ消息队列

1 为什么要用消息队列（应用场景）

消息队列是一种先进先出的数据结构。应用场景：解耦，异步，削峰

解耦 就是 假设 系统A rpc调用了 b ，c ，d系统，现在用MQ进行 消息传输，系统A就不和其他系统耦合了。

异步：利用MQ去传输数据，自己可以更快的做响应，但是用MQ是要基于系统A不依赖于其他系统的结果

削峰：利用MQ去缓解数据库压力，当QPS有很多的时候，MQ装消息，有个系统可以进行每秒读取MQ的消息多少多少然后进行数据库读写

2 各种消息队列产品的比较

| 特性 | kafka | rabbitMQ | rocketMQ |
| :--- | :--- | :--- | :--- |
| 开发语言 | scala | erlang | java |
| 单机吞吐量 | 10万级 | 万级 | 10万级 |
| 时效性 | ms级 | us级 | ms |
| 可用性 | 非常高（分布式 | 高（主从架构 | 非常高（分布式 |
| 功能特性 | 支持主要的MQ，像一些消息查询和消息回溯功能没有提供，在大数据领域应用广 | 并发能力很强，性能很好，管理界面丰富 | MQ功能比较完备，扩展性佳 |



3 消息队列的优点和缺点

优点：解耦，异步，削峰

缺点：系统可用性降低（如果MQ挂了，整个系统都崩了，解决办法：集群），系统复杂度提高（消息丢失，消息重复消费，消息顺序都导致了系统复杂度），一致性问题（某个系统处理消息失败）

4 如何保证消息队列的高可用

rabbitMQ的高可用解决架构方案：镜像集群，实际数据同步到所有的MQ节点

rocketMQ：双主双从：producer给 nameserver集群去要一个master的地址（管理着Broker master）然后producer把消息给到master1或master2。自动备份数据给自己的slave，consumer集群会从slave读取

5 如何保证消息不丢失

消息丢失的原因：1 生产者没有成功发送消息，2 MQ还没进行持久化，就宕机了 3 消费者拿到数据，还没处理，客户端宕机了

解决办法：生产者 发送消息给MQ，MQ要发送confirm确认保证拿到数据，MQ拿到数据立即进行持久化存储到db，消费者如果处理完毕发送ack确认，这时mq删除已处理的数据。

6 如何保证消息不被重复消费

产生原因：1生产者发送消息，但是由于网络抖动等问题，没有收到confirm确认，所以会再次进行发送 2 消费者消费了一条，但是由于网络抖动等问题， ack传回去失败了，结果MQ再次发送同一条数据

解决方案：消费者传送数据带上一个全局唯一的消息id，消费者获取消费后先根据id在db查询是否存在消费记录，如果消费过就直接舍弃

7 如何保证消息消费的顺序性

顺序消息同时进入一个queue，保证局部的消费顺序。然后MQ使用分段锁保证当个queue中的有序消费

8 大量消息堆积处理怎么处理

消息堆积的原因：消费者没有消费，还有就是消费者没有进行ack确认

解决方案：将堆积消息转存到容量更大的MQ集群，增加多个消费者

9 消息过期怎么处理

消息过期的原因：消息有时间，过期了还没被处理

方案：有一个死信队列专门负责装过期消息，有个死信队列消费者负责记录过期消息到数据库，再让生产者去查询数据库消息日志，重新发送到MQ









