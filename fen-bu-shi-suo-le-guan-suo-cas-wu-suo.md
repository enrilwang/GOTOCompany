# 分布式锁，乐观锁，CAS（无锁）

让我们一起来看看这三个锁的演变和区别

## 分布式锁（更像悲观锁）

对于分布式的锁服务，一般可以用数据库DB，Redis，和ZooKeeper等实现。分布式锁有以下几个特点

* **安全性**（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）
* **避免死锁**：客户端最终一定可以获得锁
* **容错性**：只要锁服务集群中的大部分节点存活，Client就可以进行加锁解锁操作

对于避免死锁，可以设定锁的锁定时间，当资源被锁定超过这个时间是，锁将自动释放。还有另一种方法是使用时间戳+客户端编号的方式生成随机数。

## 乐观锁（版本号）

* 锁服务需要有一个单调递增的版本号
* 写数据的时候，也需要带上自己的版本号
* 数据库服务需要保存数据的版本号，然后对请求做检查。

实际情况下，乐观锁+重试机制会好

## CAS锁：

先把库存数量（stock）查出来，然后在更新的时候，检查一下是否是上次读出来的库存。

关于CAS等原子操作， 一个很重要的技术就是CAS操作（Compare & Swap），**现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。**有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。

用double-CAS（双保险的CAS）来解决ABA的问题 

1）一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。

2）只有这两个都一样，才算通过检查，赋新的值的同时并把计数器累加1。



最后我们来谈谈分布式锁设计的重点。分布式锁的特点是，保证在一个集群种，同一个方法在同一时间只能被一台机器上的一个线程执行，这就是所谓的分布式互斥。所以大家在做某个事的时候，要去一个服务上请求一个标识。如果请求到了就操作。没有请求到的话就把标识换回去。

所以需要分清楚：是用来修改某个共享源的还是用来不同进程间的同步或是互斥的。如果使用CAS这样的方式来更新数据，那是不需要分布式锁服务的，而后者应该是需要的。如果确定要分布式锁服务。需要考虑下面几个设计

* 需要避免死锁的问题（让锁释放的方式）。Redis使用超时时间，ZooKeeper可以依靠自身的sessionTimeout来删除节点。
* 分布式锁服务是高可用和持久化的
* 要提供非阻塞方式的锁服务
* 考虑锁的可重入性

